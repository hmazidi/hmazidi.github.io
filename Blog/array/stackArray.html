	<!DOCTYPE html>
	<html>
		<head>
			<title>composing the code!</title>
			<link rel="shortcut icon" href="../icon.png">
			<!-- link to main stylesheet -->
			<link rel="stylesheet" type="text/css" href="MyFontsWebfontsKit.css">
			<link rel="stylesheet" type="text/css" href="/css/main.css">
		        <link rel="stylesheet" type="text/css" href="/css/prism.css">
			<script type="text/javascript" src="/prism.js"></script>
			<style>
					html{
						background-image:none;
					}
					</style>
	  </head>

	  <body>

	<script type="text/javascript" async
	  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
	</script>

	<article>
		<p> In this article, we explore the idea of stack by solving two related questions. The idea
            of stack is to allow temporary information be stored and used in a later time by pushing
            and poping operations.
			</p>  
			
		  <section>
		  <h2 class="splashHeader">
		  push/pop while traverse! 
		  </h2>
	<p class="problemStatement"> <b> Given a list of daily temperatures \(T\), 
        return a list such that, for each day in the input, tells you how many 
        days you would have to wait until a warmer temperature.
         If there is no future day for which this is possible, put \(0\) instead 
         (<a href="https://leetcode.com/problems/daily-temperatures">credit </a>).
		</b> </p>
	 
		  <p> Our first clue is that if bunch of consecutive temperatures are decreasing, as soon as 
              we see a positive change in the temperature we need to trigger some housekeeping! 
              Particularly, we know that all the days with lower temperature 
              than the current day we can exactly compute the number of days we need to wait. Further, if some of the earlier
              days have even higher temperature we need to keep the "hot" days in order. This means that 
              when we pruned the days with lower temperature, we put the current day in the correct position 
              with respect to hot days.</p>

              <p>
                  Stack is useful here since we can push the days into it and when we see a 
				  positive change we pop out the days with lower temperature and push the current day
				  on top of the stack. This ensures that we keep the correct order w.r.t. hot days! Note that
				  a sub-optimal way to solve this problem is to check for each day the condition of
				  the positive change. This approach gives \(O(N^2)\) complexity.
              </p>


              
    <p>
	<pre>
	<code class="language-python">
	Class Solution:
        def dailyTemperatures(self, T):
        """
        :type T: List[int]
        :rtype: List[int]
        """

        if not T:
            
            return []
        
        res=[0]*len(T)
        stack=[]

        for i,v in enumerate(T):
            #check if a positive change happened
			while stack and T[stack[-1]]<=v-1:
                t=stack.pop()
                res[t]=i-t
            stack.append(i)
		return res   
			
	</code>
	</pre>
	</p>

	<p class="problemStatement"> <b> Given an integer array, 
		you need to find one continuous subarray that if you only 
		sort this subarray in ascending order, then the whole array will
		 be sorted in ascending order, too.
		You need to find the shortest such subarray and output its length. 
         (<a href="https://leetcode.com/problems/shortest-unsorted-continuous-subarray/">credit </a>).
		</b> </p>
		  
		<p> So why stack is useful here? The key point is that as we traverse the array,
			we need to know the <i>left-most element</i> (LME) that is larger than the current element.
			Also, as we are going backward to find the LME that is larger than the current one, 
			we can delete those elements that are right to the LME. This justifies the
			pop() operation and thus the use of stack.

			Similarly, we want to find  the right-most element (RME) that is larger than the 
			current element. Again, it is necessary to take it into account for otherwise
			our sorting is wrong. The logic is the same as above.

			What is the time complexity? we need to  visit all the elements of the array, thereby
			the lower bound is \(O(N)\). Now for backtracking, the worse situation is that we need
			to go back N times, but this happens once thanks to stack. Thus complexity is still
			\(O(N)\).  
		</p>

		<p>
		<pre>
		<code class="language-python">

			class Solution:
			def findUnsortedSubarray(self, nums):
				"""
				:type nums: List[int]
				:rtype: int
				"""
				if len(nums)<2:
		
					return 0

				left_indx=len(nums)
				right_indx=-1
				
				// let's find the left-most element and its index
				// stack holds the indices of the recent elements
				stack=[0]
				
				for i in range(len(nums)-1):

					// if increasing add the element to the stack
					if nums[i]<=nums[i+1]:
						stack.append(i+1)

					elif stack:
						
						// get the top element in the stack
						cur_indx=stack.pop()
						// update the left_index for now
						left_indx=min(left_indx,cur_indx)

						// if the element with index cur_indx 
						// is less that or equal than nums[i+1], we are done 
						// with backtracking 

						while(nums[cur_indx]>nums[i+1]):

							// update
							left_indx=min(left_indx,cur_indx-1)

							// next element in the stack
							if stack:
								cur_indx=stack.pop()
							else:
								break
						// push back the found element to the stack 		
						stack.append(cur_indx)
				

				// do the same for the right-most element	

				stack=[len(nums)-1]
				
				for i in range(len(nums)-1,0,-1):
					
					if nums[i]>=nums[i-1]:
						stack.append(i-1)

					elif stack:
						
						cur_indx=stack.pop()

						right_indx=max(right_indx,cur_indx)

						while(nums[cur_indx]< nums[i-1]):

							right_indx= max(right_indx,cur_indx+1)

							if stack:
								cur= stack.pop()
							else:
								break
						stack.append(cur_indx)
						
							
				// calculate the number of elements between two indices
				if left_indx==len(nums) and right_indx==-1:

					return 0
				else:
				
					return right_indx-left_indx-1
				

				</code>
				</pre>
				</p>
	</section>
</article>
</body>
</html>
