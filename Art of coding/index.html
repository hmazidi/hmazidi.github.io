
<!DOCTYPE html>
<html>
	<head>
		<title>composing the code!</title>
		<!-- link to main stylesheet -->
		<link rel="stylesheet" type="text/css" href="/css/main.css">
  </head>
  <body>
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
	  
	  <article>
	  
	  <p> In this section we discuss combination of two general algorithmic approaches, namely <em>sliding window</em> and <em>hashmap</em>, to solve some of problems related to arrays having 
	 specific structures. The basic idea behind sliding window is that when iterating through an array the relevent information 
	  in the some of the visited elements is zero. In particular, these elements form a contiguous subarray. Hence, we as well may keep a window of
	  certain size and sldie it forward as we iterate. The beauty of sliding window is that it reduces the computation to \(O(n)\).</p>
		  <p> Along the same line of idea, hashmap provides a fast search medium to store information that were already obtained. 
			  This would reduce the computation cost to e.g., \(O(n)\) in a trade off with \(O(n)\) space complexity.</p>
<p> <b> Given an array \(A\) of \(n\) positive integers and a positive integer \(s\), find the minimal length of a contiguous subarray of which the sum \(â‰¥ s\). If there isn't one, return \(0\) instead.
	</b> </p>
<p>As a problem solver we need to pay attention to the conditions of the problem in order to adjust to it. In this problem, the positiveness
of the array elements defines a useful structure on this array. In particular, this positive structure implies the following:</p>
  

	  
	  <p> Let \(k\in [0,n-1)\). Then if \(\sum_{i=0}^{k} a_{i} \geq s\), it follows that \(\forall j>k, \sum_{i=0}^{j} a_{i} \geq s\).</p>
    <p> Simply put, if we encounter a contiguous subarray with sum\(\geq s\) we can safely ignore the first element of the current subarray 
      as it contains no additional information. This is exactly an instance of a sliding window.</p>
      <p> Another observation is that when we have computed the sum of a subarray it is really easy to compute the next subarray as it requires 
        adding one element.
     </p>
  <img src="https://hmazidi.github.io/images/minlengthsubarrayc++.png" class="flr" alt="minlengthsubarrayc++" width="400" height="400">
	  
		  
	  <p> Next, we look into a similar problem where there is no positive structure in the array.</p>
		  
	  </article>
	 
	  <p>
		 <b> Given an array \(A\), nums, and a target value \(k\), find the maximum length of a subarray that sums to \(k\).
			 If there isn't one, return \(0\) instead.</b>
	  </p>
		  <p> The idea here is that as we increment cursum there is alwasy a possibility of \(\sum_{i=\text{left}}^{\text{right}} a[i]=k\) for some
		  index \(\text{left}\). It seems that we need to compute bunch of summations every time we increment the right index. However,
			  
			  all we need is to store these sums somewhere and whenever we need them we can retreive them fast. In fact, a <em>hashmap</em> is 
			  presicely based on this idea. The idea is shown below </p>
			  
			<p>  <img src="https://hmazidi.github.io/images/array.png" class="flr" alt="minlengthsubarrayc++" width="350" height="250">
                        </p>
				
	  <p>Therefore all we need to compute is cursum and storing it in a hashmap <em>AllSums</em> along with its index. Note that it is possible to find subarrays with the same sum. In this case we only need to
	       store the one with minimum left index!
	  
	  <p>  <img src="https://hmazidi.github.io/images/maxlengthsubarrayc++.png" class="flr" alt="maxlengthsubarrayc++" width="400" height="400">
                        </p>
	  
	  </p>
	  
 
<p> <b> Given an array of \(n\) positive integers, find the number of subarrays 
	such that product of the elements of those subarrays are less than \(k\).</b> </p>
	
	<p> A similar problem to one of the previous subarray type problems. In fact, the idea is the same. Just exploit positiveness and 
	subarray structure to solve it efficiently. First, we focus on a \(O(n)\) algorithm via sliding window.
		
	<p> We start with left and right indices set to zero. We move the right index forward in two cases: 1) eighter the left index coincides
		with the right index, and 2) when the product of a subarray within the current window is smaller that \(k\). The reason for the first case is
		trivial. However, in the second case positivity of integers implies that all subsequent subarrays in the current window have product smaller 
		than \(k\).
		
		<p>
			  <img src="https://hmazidi.github.io/images/numsubarray.png" class="flr" alt="numsubarrayc++" width="400" height="400">
	</p>

 </body>
</html>

