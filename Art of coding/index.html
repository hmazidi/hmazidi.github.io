
<!DOCTYPE html>
<html>
	<head>
		<title>composing the code!</title>
		<!-- link to main stylesheet -->
		<link rel="stylesheet" type="text/css" href="MyFontsWebfontsKit.css">
		<link rel="stylesheet" type="text/css" href="/css/main.css">
	        <link rel="stylesheet" type="text/css" href="/css/prism.css">
		<script type="text/javascript" src="/prism.js"></script>
  </head>
  <body>

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
	  <h1>
		  Code up!
		  </h1>
	  <article>
	  
	  <p> In this section we discuss combination of two general algorithmic approaches, namely <em>sliding window</em> and <em>hashmap</em>, to solve some of problems related to arrays having 
	 specific structures. The basic idea behind sliding window is that when iterating through an array the relevent information 
	  in the some of the visited elements is zero. In particular, these elements form a contiguous subarray. Hence, we as well may keep a window of
	  certain size and sldie it forward as we iterate. The beauty of sliding window is that it reduces the computation to \(O(n)\).</p>
		  <p> Along the same line of idea, hashmap provides a fast search medium to store information that were already obtained. 
			  This would reduce the computation cost to e.g., \(O(n)\) in a trade off with \(O(n)\) space complexity.</p>
<p> <b> Given an array \(A\) of \(n\) positive integers and a positive integer \(s\), find the minimal length of a contiguous subarray of which the sum \(â‰¥ s\). If there isn't one, return \(0\) instead.
	</b> </p>
<p>As a problem solver we need to pay attention to the conditions of the problem in order to adjust to it. In this problem, the positiveness
of the array elements defines a useful structure on this array. In particular, this positive structure implies the following:</p>
  

	  
	  <p> Let \(k\in [0,n-1)\). Then if \(\sum_{i=0}^{k} a_{i} \geq s\), it follows that \(\forall j>k, \sum_{i=0}^{j} a_{i} \geq s\).</p>
    <p> Simply put, if we encounter a contiguous subarray with sum\(\geq s\) we can safely ignore the first element of the current subarray 
      as it contains no additional information. This is exactly an instance of a sliding window.</p>
      <p> Another observation is that when we have computed the sum of a subarray it is really easy to compute the next subarray as it requires 
        adding one element.
	   
<pre>
<code class="language-cpp">
Class Solution{
public:
int SubArrayLen(int s,vector&lt int&gt & nums>){
 if(nums.empty()) return 0;
 int left=0;
 int right=0;
 int cursum=0;
 int MinLength=nums.size()+1;

 while(right&lt nums.size()){
   cursum+=nums[right];
   if (cursum>=s){
       MinLength=min(MinLength,right-left+1);
       while(cursum-nums[left]&gt =s){
           cursum-=nums[left];
           left++;
           MinLength=min(MinLength,right-left+1);
       }
   }
   right++;
 }
 return MinLength==nums.size()+1 ? 0:MinLength
}
};

</code>
</pre>
 </p>
 <!-- <img src="https://hmazidi.github.io/images/minlengthsubarrayc++.png" class="flr" alt="minlengthsubarrayc++" width="400" height="400">-->
	  
		  
	  <p> Next, we look into a similar problem where there is no positive structure in the array.</p>
		  
	  </article>
	 
	  <p>
		 <b> Given an array \(A\), nums, and a target value \(k\), find the maximum length of a subarray that sums to \(k\).
			 If there isn't one, return \(0\) instead.</b>
	  </p>
		  <p> The idea here is that as we increment cursum there is alwasy a possibility of \(\sum_{i=\text{left}}^{\text{right}} a[i]=k\) for some
		  index \(\text{left}\). It seems that we need to compute bunch of summations every time we increment the right index. However,
			  
			  all we need is to store these sums somewhere and whenever we need them we can retreive them fast. In fact, a <em>hashmap</em> is 
			  presicely based on this idea. </p>
				
	  <p>Therefore all we need to compute is cursum and storing it in a hashmap <em>AllSums</em> along with its index. Note that it is possible to find subarrays with the same sum. In this case we only need to
	       store the one with minimum left index!
	  <pre>
<code class="language-cpp">
Class Solution{
public:
int MaxSubArrayLen(int k,vector&lt int&gt & nums>){
 if (nums.emty()) return 0;
 int maxlength=nums.size()+1;
 unordered_map&ltint,int&gt AllSums;
 int cursum=0;
 AllSums[0]=-1;
 for (int i=0;i&lt nums.size();i++){
     cursum=cursum+nums[i];
     if(AllSums.find(cursum)==AllSums.end()) AllSums.emplace(cursum,i);
     if(AllSums.find(cursum-k)!=AllSums.end()) maxlength=max(maxlength,i-AllSums[cursum-k];
 }
 return maxlength==nums.size()+1?0:maxlength;
 }
 };
     
</code>
</pre>
	</p>

	 
	<p> To see another interesting idea of storing intermediate results, consider the following 
		problem: </p>


<p>
   <b> Given an array \(A\), nums, of \(N\) integers, find the smallest positive integer that is 
	   missing in \(A\).</b>
</p>
<p>Obviously, we can sort the array nums and look for the first positive integer
	that is missing. This approach natually has \(O(N \log(N))\) complexity. Can we do better?
	 We start with the need for sorting. The difficulty arises from the observation that as we
	 traverse the array, the collection of elements contain  critical information about the missing positive integer. 
	 For instance, consider \(A=[5, 1, 2, 3, 4]\). The first element of \(A\), 5, only becomes
	 critical when we understand that the element 4 exists, which happens at the very end. The single fact that 
	 5 occurs sooner than 4, seems to force us to traceback the array each time a positive element is found.   
</p>
<p>Here, we devise a strategy to encode the information of intermediate positive elements. As \(A\) has at most \(N\) 
positive elements, we can assume that the missing positive number is at most \(N+1\). Thus, we construct 
an index array of length \(N+1\) with all ones. As we traverse \(A\), if we find a positive integer, 
we set the value of its corresponding index to 0. At the end, we traverse back this array to get the first index with value 1.
</p>
<pre>
<code class="language-pyhton">
Class Solution:
	def findMissingPosInt(nums):
		num_el=len(nums)
		indxArray=[1]*(num_el+1)

		for i in range(num_el):
			if nums[i]>0 and nums[i]<=num_el:
				indxArray[nums[i]-1]=0
					
		for i in range(num_el+1):
			if indxArray[i]==1:
					
				return i+1
</code>
</pre>
	 
 </body>
</html>

